<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>AI æ‰‹åŠ¿äº¤äº’ 3D åœ£è¯æ ‘</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; color: white; font-family: sans-serif; }
        #container { width: 100vw; height: 100vh; }
        .ui-overlay { position: absolute; top: 20px; left: 20px; z-index: 10; pointer-events: none; }
        video { position: absolute; bottom: 20px; right: 20px; width: 240px; border-radius: 10px; border: 2px solid #00ff88; transform: scaleX(-1); }
        .loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.5rem; }
    </style>
</head>
<body>

    <div class="ui-overlay">
        <h1>AI Gesture Xmas Tree</h1>
        <p>ğŸ– ä¼¸å‡ºä½ çš„æ‰‹æ¥æ“æ§ç²’å­ï¼</p>
    </div>
    <div id="loading" class="loading">æ­£åœ¨åˆå§‹åŒ– AI æ¨¡å‹å’Œåœºæ™¯...</div>
    <video id="video" autoplay playsinline></video>
    <div id="container"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        let scene, camera, renderer, particles, geometry;
        const particleCount = 5000;
        let positions = [];
        let targetTree = [];
        let targetCloud = [];
        let currentMode = 'tree'; // tree or cloud

        const videoElement = document.getElementById('video');
        const loading = document.getElementById('loading');

        // --- åˆå§‹åŒ–åœºæ™¯ ---
        function initScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            // åˆ›å»ºç²’å­å‡ ä½•ä½“
            geometry = new THREE.BufferGeometry();
            const initPos = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                // åœ£è¯æ ‘å½¢æ€ (åœ†é”¥)
                const h = Math.random() * 4 - 2;
                const radius = (2 - h) * 0.5;
                const angle = Math.random() * Math.PI * 2;
                targetTree.push(Math.cos(angle) * radius, h, Math.sin(angle) * radius);

                // ç…§ç‰‡äº‘å½¢æ€ (çƒä½“)
                const phi = Math.acos(-1 + Math.random() * 2);
                const theta = Math.random() * Math.PI * 2;
                const r = 2.5;
                targetCloud.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );

                // åˆå§‹ä½ç½®éšæœº
                initPos[i * 3] = (Math.random() - 0.5) * 10;
                initPos[i * 3 + 1] = (Math.random() - 0.5) * 10;
                initPos[i * 3 + 2] = (Math.random() - 0.5) * 10;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(initPos, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.04,
                color: 0x00ff88,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // çª—å£è‡ªé€‚åº”
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- MediaPipe æ‰‹åŠ¿å¤„ç† ---
        const handTip = new THREE.Vector3();
        let isHandVisible = false;

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandVisible = true;
                const landmark = results.multiHandLandmarks[0][8]; // é£ŸæŒ‡æŒ‡å°–
                // åæ ‡è½¬æ¢ï¼šMediaPipe (0~1) -> Three.js (-æ¯”ä¾‹, +æ¯”ä¾‹)
                handTip.x = (landmark.x - 0.5) * -10; 
                handTip.y = (0.5 - landmark.y) * 10;
                
                // æ£€æŸ¥æ˜¯å¦æ¡æ‹³ï¼ˆç®€å•åˆ¤æ–­ï¼šé£ŸæŒ‡æŒ‡å°–ä¸æŒå¿ƒè·ç¦»ï¼‰æ¥åˆ‡æ¢å½¢æ€
                const wrist = results.multiHandLandmarks[0][0];
                const dist = Math.hypot(landmark.x - wrist.x, landmark.y - wrist.y);
                currentMode = dist < 0.15 ? 'cloud' : 'tree';
            } else {
                isHandVisible = false;
            }
        });

        const cameraMP = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
                if (loading.style.display !== 'none') loading.style.display = 'none';
            },
            width: 640,
            height: 480
        });
        cameraMP.start();

        // --- åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            const posAttr = geometry.attributes.position;
            const targetData = currentMode === 'tree' ? targetTree : targetCloud;

            for (let i = 0; i < particleCount; i++) {
                let ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2;

                // 1. åŸºç¡€å¹³æ»‘ç§»åŠ¨åˆ°ç›®æ ‡å½¢çŠ¶
                posAttr.array[ix] += (targetData[ix] - posAttr.array[ix]) * 0.05;
                posAttr.array[iy] += (targetData[iy] - posAttr.array[iy]) * 0.05;
                posAttr.array[iz] += (targetData[iz] - posAttr.array[iz]) * 0.05;

                // 2. æ‰‹åŠ¿å¹²æ‰°æ•ˆæœ
                if (isHandVisible) {
                    const dx = handTip.x - posAttr.array[ix];
                    const dy = handTip.y - posAttr.array[iy];
                    const dz = handTip.z - posAttr.array[iz];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

                    if (dist < 1.5) {
                        const force = (1.5 - dist) * 0.1;
                        posAttr.array[ix] -= dx * force;
                        posAttr.array[iy] -= dy * force;
                        posAttr.array[iz] -= dz * force;
                    }
                }
            }

            posAttr.needsUpdate = true;
            particles.rotation.y += 0.005; // æŒç»­è‡ªè½¬

            renderer.render(scene, camera);
        }

        // å¯åŠ¨
        initScene();
        animate();
    </script>
</body>
</html>